// *** WARNING: this file was generated by pulumi-language-dotnet. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Yandex
{
    /// <summary>
    /// Allows management of [Yandex Cloud Backup Policy](https://yandex.cloud/docs/backup/concepts/policy).
    /// 
    /// &gt; Cloud Backup Provider must be activated in order to manipulate with policies. Active it either by UI Console or by `yc` command.
    /// 
    /// ## Defined types
    /// 
    /// ### interval_type
    /// 
    ///  A string type, that accepts values in the format of: `number` + `time type`, where `time type` might be:
    /// * `s` — seconds
    /// * `m` — minutes
    /// * `h` — hours
    /// * `d` — days
    /// * `w` — weekdays
    /// * `M` — months
    /// 
    /// Example of interval value: `5m`, `10d`, `2M`, `5w`
    /// 
    /// ### day_type
    /// 
    /// A string type, that accepts the following values: `ALWAYS_INCREMENTAL`, `ALWAYS_FULL`, `WEEKLY_FULL_DAILY_INCREMENTAL`, `WEEKLY_INCREMENTAL`.
    /// 
    /// ### backup_set_type
    /// 
    /// `TYPE_AUTO`, `TYPE_FULL`, `TYPE_INCREMENTAL`, `TYPE_DIFFERENTIAL`.
    /// 
    /// ## Example Usage
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Yandex = Pulumi.Yandex;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     //
    ///     // Create a new basic Cloud Backup Policy
    ///     //
    ///     var basicPolicy = new Yandex.BackupPolicy("basicPolicy", new()
    ///     {
    ///         Reattempts = null,
    ///         Retention = new Yandex.Inputs.BackupPolicyRetentionArgs
    ///         {
    ///             AfterBackup = false,
    ///         },
    ///         Scheduling = new Yandex.Inputs.BackupPolicySchedulingArgs
    ///         {
    ///             BackupSets = new[]
    ///             {
    ///                 new Yandex.Inputs.BackupPolicySchedulingBackupSetArgs
    ///                 {
    ///                     ExecuteByInterval = 86400,
    ///                 },
    ///             },
    ///             Enabled = false,
    ///         },
    ///         VmSnapshotReattempts = null,
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Yandex = Pulumi.Yandex;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     //
    ///     // Create a new full Cloud Backup Policy
    ///     //
    ///     var myPolicy = new Yandex.BackupPolicy("myPolicy", new()
    ///     {
    ///         ArchiveName = "[Machine Name]-[Plan ID]-[Unique ID]a",
    ///         Cbt = "USE_IF_ENABLED",
    ///         Compression = "NORMAL",
    ///         FastBackupEnabled = true,
    ///         Format = "AUTO",
    ///         MultiVolumeSnapshottingEnabled = true,
    ///         PerformanceWindowEnabled = true,
    ///         PreserveFileSecuritySettings = true,
    ///         QuiesceSnapshottingEnabled = true,
    ///         Reattempts = new Yandex.Inputs.BackupPolicyReattemptsArgs
    ///         {
    ///             Enabled = true,
    ///             Interval = "1m",
    ///             MaxAttempts = 10,
    ///         },
    ///         Retention = new Yandex.Inputs.BackupPolicyRetentionArgs
    ///         {
    ///             AfterBackup = false,
    ///             Rules = new[]
    ///             {
    ///                 new Yandex.Inputs.BackupPolicyRetentionRuleArgs
    ///                 {
    ///                     MaxAge = "365d",
    ///                     RepeatPeriod = new() { },
    ///                 },
    ///             },
    ///         },
    ///         Scheduling = new Yandex.Inputs.BackupPolicySchedulingArgs
    ///         {
    ///             BackupSets = new[]
    ///             {
    ///                 new Yandex.Inputs.BackupPolicySchedulingBackupSetArgs
    ///                 {
    ///                     ExecuteByTime = new[]
    ///                     {
    ///                         
    ///                         {
    ///                             { "includeLastDayOfMonth", true },
    ///                             { "monthdays", new[] {} },
    ///                             { "months", new[]
    ///                             {
    ///                                 1,
    ///                                 2,
    ///                                 3,
    ///                                 4,
    ///                                 5,
    ///                                 6,
    ///                                 7,
    ///                                 8,
    ///                                 9,
    ///                                 10,
    ///                                 11,
    ///                                 12,
    ///                             } },
    ///                             { "repeatAt", new[]
    ///                             {
    ///                                 "04:10",
    ///                             } },
    ///                             { "repeatEvery", "30m" },
    ///                             { "type", "MONTHLY" },
    ///                             { "weekdays", new[] {} },
    ///                         },
    ///                     },
    ///                 },
    ///             },
    ///             Enabled = false,
    ///             MaxParallelBackups = 0,
    ///             RandomMaxDelay = "30m",
    ///             Scheme = "ALWAYS_INCREMENTAL",
    ///             WeeklyBackupDay = "MONDAY",
    ///         },
    ///         SilentModeEnabled = true,
    ///         SplittingBytes = "9223372036854775807",
    ///         VmSnapshotReattempts = new Yandex.Inputs.BackupPolicyVmSnapshotReattemptsArgs
    ///         {
    ///             Enabled = true,
    ///             Interval = "1m",
    ///             MaxAttempts = 10,
    ///         },
    ///         VssProvider = "NATIVE",
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// ## Import
    /// 
    /// The resource can be imported by using their `resource ID`. For getting the resource ID you can use Yandex Cloud [Web Console](https://console.yandex.cloud) or [YC CLI](https://yandex.cloud/docs/cli/quickstart).
    /// 
    /// bash
    /// 
    /// ```sh
    /// $ pulumi import yandex:index/backupPolicy:BackupPolicy &lt;resource Name&gt; &lt;Resource Id&gt;
    /// ```
    /// 
    /// ```sh
    /// $ pulumi import yandex:index/backupPolicy:BackupPolicy my_backup_policy ...
    /// ```
    /// </summary>
    [YandexResourceType("yandex:index/backupPolicy:BackupPolicy")]
    public partial class BackupPolicy : global::Pulumi.CustomResource
    {
        /// <summary>
        /// The name of generated archives. Default `[Machine Name]-[Plan ID]-[Unique ID]a`.
        /// </summary>
        [Output("archiveName")]
        public Output<string?> ArchiveName { get; private set; } = null!;

        /// <summary>
        /// Configuration of Changed Block Tracking. Available values are: `USE_IF_ENABLED`, `ENABLED_AND_USE`, `DO_NOT_USE`. Default `DO_NOT_USE`.
        /// </summary>
        [Output("cbt")]
        public Output<string?> Cbt { get; private set; } = null!;

        /// <summary>
        /// Archive compression level. Affects CPU. Available values: `NORMAL`, `HIGH`, `MAX`, `OFF`. Default: `NORMAL`.
        /// </summary>
        [Output("compression")]
        public Output<string?> Compression { get; private set; } = null!;

        /// <summary>
        /// The creation timestamp of the resource.
        /// </summary>
        [Output("createdAt")]
        public Output<string> CreatedAt { get; private set; } = null!;

        /// <summary>
        /// If this field is true, it means that the policy is enabled.
        /// </summary>
        [Output("enabled")]
        public Output<bool> Enabled { get; private set; } = null!;

        /// <summary>
        /// If true, determines whether a file has changed by the file size and timestamp. Otherwise, the entire file contents are compared to those stored in the backup.
        /// </summary>
        [Output("fastBackupEnabled")]
        public Output<bool?> FastBackupEnabled { get; private set; } = null!;

        /// <summary>
        /// File filters to specify masks of files to backup or to exclude of backuping.
        /// </summary>
        [Output("fileFilters")]
        public Output<Outputs.BackupPolicyFileFilters?> FileFilters { get; private set; } = null!;

        /// <summary>
        /// The folder identifier that resource belongs to. If it is not provided, the default provider `folder-id` is used.
        /// </summary>
        [Output("folderId")]
        public Output<string> FolderId { get; private set; } = null!;

        /// <summary>
        /// Format of the backup. It's strongly recommend to leave this option empty or `AUTO`. Available values: `AUTO`, `VERSION_11`, `VERSION_12`.
        /// </summary>
        [Output("format")]
        public Output<string?> Format { get; private set; } = null!;

        /// <summary>
        /// LVM will be used to create the volume snapshot. If LVM fails to create a snapshot (for example, because there is not enough free space), the software will create the snapshot itself.
        /// </summary>
        [Output("lvmSnapshottingEnabled")]
        public Output<bool?> LvmSnapshottingEnabled { get; private set; } = null!;

        /// <summary>
        /// If true, snapshots of multiple volumes will be taken simultaneously. Default `true`.
        /// </summary>
        [Output("multiVolumeSnapshottingEnabled")]
        public Output<bool?> MultiVolumeSnapshottingEnabled { get; private set; } = null!;

        /// <summary>
        /// The resource name.
        /// </summary>
        [Output("name")]
        public Output<string> Name { get; private set; } = null!;

        /// <summary>
        /// Time windows for performance limitations of backup. Default `false`.
        /// </summary>
        [Output("performanceWindowEnabled")]
        public Output<bool?> PerformanceWindowEnabled { get; private set; } = null!;

        /// <summary>
        /// If true, a quiesced snapshot of the virtual machine will be taken. Default `true`.
        /// </summary>
        [Output("preserveFileSecuritySettings")]
        public Output<bool?> PreserveFileSecuritySettings { get; private set; } = null!;

        /// <summary>
        /// If true, a quiesced snapshot of the virtual machine will be taken. Default `true`.
        /// </summary>
        [Output("quiesceSnapshottingEnabled")]
        public Output<bool?> QuiesceSnapshottingEnabled { get; private set; } = null!;

        /// <summary>
        /// Amount of reattempts that should be performed while trying to make backup at the host.
        /// </summary>
        [Output("reattempts")]
        public Output<Outputs.BackupPolicyReattempts> Reattempts { get; private set; } = null!;

        /// <summary>
        /// Retention policy for backups. Allows to setup backups lifecycle.
        /// </summary>
        [Output("retention")]
        public Output<Outputs.BackupPolicyRetention> Retention { get; private set; } = null!;

        /// <summary>
        /// Schedule settings for creating backups on the host.
        /// </summary>
        [Output("scheduling")]
        public Output<Outputs.BackupPolicyScheduling> Scheduling { get; private set; } = null!;

        /// <summary>
        /// A sector-by-sector backup of a disk or volume creates a backup copy of all sectors of the disk or volume, including those that do not contain data. Therefore, the size of such a backup copy will be equal to the size of the original disk or volume.
        /// </summary>
        [Output("sectorBySector")]
        public Output<bool?> SectorBySector { get; private set; } = null!;

        /// <summary>
        /// If true, a user interaction will be avoided when possible. Default `true`.
        /// </summary>
        [Output("silentModeEnabled")]
        public Output<bool?> SilentModeEnabled { get; private set; } = null!;

        /// <summary>
        /// Determines the size to split backups. It's better to leave this option unchanged. Default `9223372036854775807`.
        /// </summary>
        [Output("splittingBytes")]
        public Output<string?> SplittingBytes { get; private set; } = null!;

        /// <summary>
        /// The update timestamp of the resource.
        /// </summary>
        [Output("updatedAt")]
        public Output<string> UpdatedAt { get; private set; } = null!;

        /// <summary>
        /// Validation is a time-consuming process, even with incremental or differential backups of small amounts of data. This is because not only the data physically contained in the backup copy is verified, but all data restored when it is selected. This option requires access to previously created backup copies.
        /// </summary>
        [Output("validationEnabled")]
        public Output<bool?> ValidationEnabled { get; private set; } = null!;

        /// <summary>
        /// Amount of reattempts that should be performed while trying to make snapshot.
        /// </summary>
        [Output("vmSnapshotReattempts")]
        public Output<Outputs.BackupPolicyVmSnapshotReattempts> VmSnapshotReattempts { get; private set; } = null!;

        /// <summary>
        /// Settings for the volume shadow copy service. Available values are: `NATIVE`, `TARGET_SYSTEM_DEFINED`. Default `NATIVE`.
        /// </summary>
        [Output("vssProvider")]
        public Output<string?> VssProvider { get; private set; } = null!;


        /// <summary>
        /// Create a BackupPolicy resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public BackupPolicy(string name, BackupPolicyArgs args, CustomResourceOptions? options = null)
            : base("yandex:index/backupPolicy:BackupPolicy", name, args ?? new BackupPolicyArgs(), MakeResourceOptions(options, ""))
        {
        }

        private BackupPolicy(string name, Input<string> id, BackupPolicyState? state = null, CustomResourceOptions? options = null)
            : base("yandex:index/backupPolicy:BackupPolicy", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing BackupPolicy resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static BackupPolicy Get(string name, Input<string> id, BackupPolicyState? state = null, CustomResourceOptions? options = null)
        {
            return new BackupPolicy(name, id, state, options);
        }
    }

    public sealed class BackupPolicyArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// The name of generated archives. Default `[Machine Name]-[Plan ID]-[Unique ID]a`.
        /// </summary>
        [Input("archiveName")]
        public Input<string>? ArchiveName { get; set; }

        /// <summary>
        /// Configuration of Changed Block Tracking. Available values are: `USE_IF_ENABLED`, `ENABLED_AND_USE`, `DO_NOT_USE`. Default `DO_NOT_USE`.
        /// </summary>
        [Input("cbt")]
        public Input<string>? Cbt { get; set; }

        /// <summary>
        /// Archive compression level. Affects CPU. Available values: `NORMAL`, `HIGH`, `MAX`, `OFF`. Default: `NORMAL`.
        /// </summary>
        [Input("compression")]
        public Input<string>? Compression { get; set; }

        /// <summary>
        /// If true, determines whether a file has changed by the file size and timestamp. Otherwise, the entire file contents are compared to those stored in the backup.
        /// </summary>
        [Input("fastBackupEnabled")]
        public Input<bool>? FastBackupEnabled { get; set; }

        /// <summary>
        /// File filters to specify masks of files to backup or to exclude of backuping.
        /// </summary>
        [Input("fileFilters")]
        public Input<Inputs.BackupPolicyFileFiltersArgs>? FileFilters { get; set; }

        /// <summary>
        /// The folder identifier that resource belongs to. If it is not provided, the default provider `folder-id` is used.
        /// </summary>
        [Input("folderId")]
        public Input<string>? FolderId { get; set; }

        /// <summary>
        /// Format of the backup. It's strongly recommend to leave this option empty or `AUTO`. Available values: `AUTO`, `VERSION_11`, `VERSION_12`.
        /// </summary>
        [Input("format")]
        public Input<string>? Format { get; set; }

        /// <summary>
        /// LVM will be used to create the volume snapshot. If LVM fails to create a snapshot (for example, because there is not enough free space), the software will create the snapshot itself.
        /// </summary>
        [Input("lvmSnapshottingEnabled")]
        public Input<bool>? LvmSnapshottingEnabled { get; set; }

        /// <summary>
        /// If true, snapshots of multiple volumes will be taken simultaneously. Default `true`.
        /// </summary>
        [Input("multiVolumeSnapshottingEnabled")]
        public Input<bool>? MultiVolumeSnapshottingEnabled { get; set; }

        /// <summary>
        /// The resource name.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// Time windows for performance limitations of backup. Default `false`.
        /// </summary>
        [Input("performanceWindowEnabled")]
        public Input<bool>? PerformanceWindowEnabled { get; set; }

        /// <summary>
        /// If true, a quiesced snapshot of the virtual machine will be taken. Default `true`.
        /// </summary>
        [Input("preserveFileSecuritySettings")]
        public Input<bool>? PreserveFileSecuritySettings { get; set; }

        /// <summary>
        /// If true, a quiesced snapshot of the virtual machine will be taken. Default `true`.
        /// </summary>
        [Input("quiesceSnapshottingEnabled")]
        public Input<bool>? QuiesceSnapshottingEnabled { get; set; }

        /// <summary>
        /// Amount of reattempts that should be performed while trying to make backup at the host.
        /// </summary>
        [Input("reattempts", required: true)]
        public Input<Inputs.BackupPolicyReattemptsArgs> Reattempts { get; set; } = null!;

        /// <summary>
        /// Retention policy for backups. Allows to setup backups lifecycle.
        /// </summary>
        [Input("retention", required: true)]
        public Input<Inputs.BackupPolicyRetentionArgs> Retention { get; set; } = null!;

        /// <summary>
        /// Schedule settings for creating backups on the host.
        /// </summary>
        [Input("scheduling", required: true)]
        public Input<Inputs.BackupPolicySchedulingArgs> Scheduling { get; set; } = null!;

        /// <summary>
        /// A sector-by-sector backup of a disk or volume creates a backup copy of all sectors of the disk or volume, including those that do not contain data. Therefore, the size of such a backup copy will be equal to the size of the original disk or volume.
        /// </summary>
        [Input("sectorBySector")]
        public Input<bool>? SectorBySector { get; set; }

        /// <summary>
        /// If true, a user interaction will be avoided when possible. Default `true`.
        /// </summary>
        [Input("silentModeEnabled")]
        public Input<bool>? SilentModeEnabled { get; set; }

        /// <summary>
        /// Determines the size to split backups. It's better to leave this option unchanged. Default `9223372036854775807`.
        /// </summary>
        [Input("splittingBytes")]
        public Input<string>? SplittingBytes { get; set; }

        /// <summary>
        /// Validation is a time-consuming process, even with incremental or differential backups of small amounts of data. This is because not only the data physically contained in the backup copy is verified, but all data restored when it is selected. This option requires access to previously created backup copies.
        /// </summary>
        [Input("validationEnabled")]
        public Input<bool>? ValidationEnabled { get; set; }

        /// <summary>
        /// Amount of reattempts that should be performed while trying to make snapshot.
        /// </summary>
        [Input("vmSnapshotReattempts", required: true)]
        public Input<Inputs.BackupPolicyVmSnapshotReattemptsArgs> VmSnapshotReattempts { get; set; } = null!;

        /// <summary>
        /// Settings for the volume shadow copy service. Available values are: `NATIVE`, `TARGET_SYSTEM_DEFINED`. Default `NATIVE`.
        /// </summary>
        [Input("vssProvider")]
        public Input<string>? VssProvider { get; set; }

        public BackupPolicyArgs()
        {
        }
        public static new BackupPolicyArgs Empty => new BackupPolicyArgs();
    }

    public sealed class BackupPolicyState : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// The name of generated archives. Default `[Machine Name]-[Plan ID]-[Unique ID]a`.
        /// </summary>
        [Input("archiveName")]
        public Input<string>? ArchiveName { get; set; }

        /// <summary>
        /// Configuration of Changed Block Tracking. Available values are: `USE_IF_ENABLED`, `ENABLED_AND_USE`, `DO_NOT_USE`. Default `DO_NOT_USE`.
        /// </summary>
        [Input("cbt")]
        public Input<string>? Cbt { get; set; }

        /// <summary>
        /// Archive compression level. Affects CPU. Available values: `NORMAL`, `HIGH`, `MAX`, `OFF`. Default: `NORMAL`.
        /// </summary>
        [Input("compression")]
        public Input<string>? Compression { get; set; }

        /// <summary>
        /// The creation timestamp of the resource.
        /// </summary>
        [Input("createdAt")]
        public Input<string>? CreatedAt { get; set; }

        /// <summary>
        /// If this field is true, it means that the policy is enabled.
        /// </summary>
        [Input("enabled")]
        public Input<bool>? Enabled { get; set; }

        /// <summary>
        /// If true, determines whether a file has changed by the file size and timestamp. Otherwise, the entire file contents are compared to those stored in the backup.
        /// </summary>
        [Input("fastBackupEnabled")]
        public Input<bool>? FastBackupEnabled { get; set; }

        /// <summary>
        /// File filters to specify masks of files to backup or to exclude of backuping.
        /// </summary>
        [Input("fileFilters")]
        public Input<Inputs.BackupPolicyFileFiltersGetArgs>? FileFilters { get; set; }

        /// <summary>
        /// The folder identifier that resource belongs to. If it is not provided, the default provider `folder-id` is used.
        /// </summary>
        [Input("folderId")]
        public Input<string>? FolderId { get; set; }

        /// <summary>
        /// Format of the backup. It's strongly recommend to leave this option empty or `AUTO`. Available values: `AUTO`, `VERSION_11`, `VERSION_12`.
        /// </summary>
        [Input("format")]
        public Input<string>? Format { get; set; }

        /// <summary>
        /// LVM will be used to create the volume snapshot. If LVM fails to create a snapshot (for example, because there is not enough free space), the software will create the snapshot itself.
        /// </summary>
        [Input("lvmSnapshottingEnabled")]
        public Input<bool>? LvmSnapshottingEnabled { get; set; }

        /// <summary>
        /// If true, snapshots of multiple volumes will be taken simultaneously. Default `true`.
        /// </summary>
        [Input("multiVolumeSnapshottingEnabled")]
        public Input<bool>? MultiVolumeSnapshottingEnabled { get; set; }

        /// <summary>
        /// The resource name.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// Time windows for performance limitations of backup. Default `false`.
        /// </summary>
        [Input("performanceWindowEnabled")]
        public Input<bool>? PerformanceWindowEnabled { get; set; }

        /// <summary>
        /// If true, a quiesced snapshot of the virtual machine will be taken. Default `true`.
        /// </summary>
        [Input("preserveFileSecuritySettings")]
        public Input<bool>? PreserveFileSecuritySettings { get; set; }

        /// <summary>
        /// If true, a quiesced snapshot of the virtual machine will be taken. Default `true`.
        /// </summary>
        [Input("quiesceSnapshottingEnabled")]
        public Input<bool>? QuiesceSnapshottingEnabled { get; set; }

        /// <summary>
        /// Amount of reattempts that should be performed while trying to make backup at the host.
        /// </summary>
        [Input("reattempts")]
        public Input<Inputs.BackupPolicyReattemptsGetArgs>? Reattempts { get; set; }

        /// <summary>
        /// Retention policy for backups. Allows to setup backups lifecycle.
        /// </summary>
        [Input("retention")]
        public Input<Inputs.BackupPolicyRetentionGetArgs>? Retention { get; set; }

        /// <summary>
        /// Schedule settings for creating backups on the host.
        /// </summary>
        [Input("scheduling")]
        public Input<Inputs.BackupPolicySchedulingGetArgs>? Scheduling { get; set; }

        /// <summary>
        /// A sector-by-sector backup of a disk or volume creates a backup copy of all sectors of the disk or volume, including those that do not contain data. Therefore, the size of such a backup copy will be equal to the size of the original disk or volume.
        /// </summary>
        [Input("sectorBySector")]
        public Input<bool>? SectorBySector { get; set; }

        /// <summary>
        /// If true, a user interaction will be avoided when possible. Default `true`.
        /// </summary>
        [Input("silentModeEnabled")]
        public Input<bool>? SilentModeEnabled { get; set; }

        /// <summary>
        /// Determines the size to split backups. It's better to leave this option unchanged. Default `9223372036854775807`.
        /// </summary>
        [Input("splittingBytes")]
        public Input<string>? SplittingBytes { get; set; }

        /// <summary>
        /// The update timestamp of the resource.
        /// </summary>
        [Input("updatedAt")]
        public Input<string>? UpdatedAt { get; set; }

        /// <summary>
        /// Validation is a time-consuming process, even with incremental or differential backups of small amounts of data. This is because not only the data physically contained in the backup copy is verified, but all data restored when it is selected. This option requires access to previously created backup copies.
        /// </summary>
        [Input("validationEnabled")]
        public Input<bool>? ValidationEnabled { get; set; }

        /// <summary>
        /// Amount of reattempts that should be performed while trying to make snapshot.
        /// </summary>
        [Input("vmSnapshotReattempts")]
        public Input<Inputs.BackupPolicyVmSnapshotReattemptsGetArgs>? VmSnapshotReattempts { get; set; }

        /// <summary>
        /// Settings for the volume shadow copy service. Available values are: `NATIVE`, `TARGET_SYSTEM_DEFINED`. Default `NATIVE`.
        /// </summary>
        [Input("vssProvider")]
        public Input<string>? VssProvider { get; set; }

        public BackupPolicyState()
        {
        }
        public static new BackupPolicyState Empty => new BackupPolicyState();
    }
}
