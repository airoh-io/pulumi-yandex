// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package yandex

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// An Instance group resource. For more information, see
// [the official documentation](https://cloud.yandex.com/docs/compute/concepts/instance-groups/).
type ComputeInstanceGroup struct {
	pulumi.CustomResourceState

	// The allocation policy of the instance group by zone and region. The structure is documented below.
	AllocationPolicy ComputeInstanceGroupAllocationPolicyOutput `pulumi:"allocationPolicy"`
	// The instance group creation timestamp.
	CreatedAt pulumi.StringOutput `pulumi:"createdAt"`
	// Flag that protects the instance group from accidental deletion.
	DeletionProtection pulumi.BoolPtrOutput `pulumi:"deletionProtection"`
	// The deployment policy of the instance group. The structure is documented below.
	DeployPolicy ComputeInstanceGroupDeployPolicyOutput `pulumi:"deployPolicy"`
	// A description of the boot disk.
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// The ID of the folder that the resources belong to.
	FolderId pulumi.StringOutput `pulumi:"folderId"`
	// Health check specifications. The structure is documented below.
	HealthChecks ComputeInstanceGroupHealthCheckArrayOutput `pulumi:"healthChecks"`
	// The template for creating new instances. The structure is documented below.
	InstanceTemplate ComputeInstanceGroupInstanceTemplateOutput `pulumi:"instanceTemplate"`
	Instances        ComputeInstanceGroupInstanceArrayOutput    `pulumi:"instances"`
	// A map of labels of metric.
	Labels pulumi.StringMapOutput `pulumi:"labels"`
	// Load balancing specifications. The structure is documented below.
	LoadBalancer ComputeInstanceGroupLoadBalancerPtrOutput `pulumi:"loadBalancer"`
	// Name template of the instance.\
	// In order to be unique it must contain at least one of instance unique placeholders:
	// {instance.short_id}
	// {instance.index}
	// combination of {instance.zone_id} and {instance.index_in_zone}
	// Example: my-instance-{instance.index}
	// If not set, default is used: {instance_group.id}-{instance.short_id}
	// It may also contain another placeholders, see metadata doc for full list.
	Name pulumi.StringOutput `pulumi:"name"`
	// The scaling policy of the instance group. The structure is documented below.
	ScalePolicy ComputeInstanceGroupScalePolicyOutput `pulumi:"scalePolicy"`
	// The ID of the service account authorized for this instance.
	ServiceAccountId pulumi.StringOutput `pulumi:"serviceAccountId"`
	// The status of the instance.
	Status pulumi.StringOutput `pulumi:"status"`
	// A set of key/value  variables pairs to assign to the instance group.
	Variables pulumi.StringMapOutput `pulumi:"variables"`
}

// NewComputeInstanceGroup registers a new resource with the given unique name, arguments, and options.
func NewComputeInstanceGroup(ctx *pulumi.Context,
	name string, args *ComputeInstanceGroupArgs, opts ...pulumi.ResourceOption) (*ComputeInstanceGroup, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.AllocationPolicy == nil {
		return nil, errors.New("invalid value for required argument 'AllocationPolicy'")
	}
	if args.DeployPolicy == nil {
		return nil, errors.New("invalid value for required argument 'DeployPolicy'")
	}
	if args.InstanceTemplate == nil {
		return nil, errors.New("invalid value for required argument 'InstanceTemplate'")
	}
	if args.ScalePolicy == nil {
		return nil, errors.New("invalid value for required argument 'ScalePolicy'")
	}
	if args.ServiceAccountId == nil {
		return nil, errors.New("invalid value for required argument 'ServiceAccountId'")
	}
	var resource ComputeInstanceGroup
	err := ctx.RegisterResource("yandex:index/computeInstanceGroup:ComputeInstanceGroup", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetComputeInstanceGroup gets an existing ComputeInstanceGroup resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetComputeInstanceGroup(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ComputeInstanceGroupState, opts ...pulumi.ResourceOption) (*ComputeInstanceGroup, error) {
	var resource ComputeInstanceGroup
	err := ctx.ReadResource("yandex:index/computeInstanceGroup:ComputeInstanceGroup", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering ComputeInstanceGroup resources.
type computeInstanceGroupState struct {
	// The allocation policy of the instance group by zone and region. The structure is documented below.
	AllocationPolicy *ComputeInstanceGroupAllocationPolicy `pulumi:"allocationPolicy"`
	// The instance group creation timestamp.
	CreatedAt *string `pulumi:"createdAt"`
	// Flag that protects the instance group from accidental deletion.
	DeletionProtection *bool `pulumi:"deletionProtection"`
	// The deployment policy of the instance group. The structure is documented below.
	DeployPolicy *ComputeInstanceGroupDeployPolicy `pulumi:"deployPolicy"`
	// A description of the boot disk.
	Description *string `pulumi:"description"`
	// The ID of the folder that the resources belong to.
	FolderId *string `pulumi:"folderId"`
	// Health check specifications. The structure is documented below.
	HealthChecks []ComputeInstanceGroupHealthCheck `pulumi:"healthChecks"`
	// The template for creating new instances. The structure is documented below.
	InstanceTemplate *ComputeInstanceGroupInstanceTemplate `pulumi:"instanceTemplate"`
	Instances        []ComputeInstanceGroupInstance        `pulumi:"instances"`
	// A map of labels of metric.
	Labels map[string]string `pulumi:"labels"`
	// Load balancing specifications. The structure is documented below.
	LoadBalancer *ComputeInstanceGroupLoadBalancer `pulumi:"loadBalancer"`
	// Name template of the instance.\
	// In order to be unique it must contain at least one of instance unique placeholders:
	// {instance.short_id}
	// {instance.index}
	// combination of {instance.zone_id} and {instance.index_in_zone}
	// Example: my-instance-{instance.index}
	// If not set, default is used: {instance_group.id}-{instance.short_id}
	// It may also contain another placeholders, see metadata doc for full list.
	Name *string `pulumi:"name"`
	// The scaling policy of the instance group. The structure is documented below.
	ScalePolicy *ComputeInstanceGroupScalePolicy `pulumi:"scalePolicy"`
	// The ID of the service account authorized for this instance.
	ServiceAccountId *string `pulumi:"serviceAccountId"`
	// The status of the instance.
	Status *string `pulumi:"status"`
	// A set of key/value  variables pairs to assign to the instance group.
	Variables map[string]string `pulumi:"variables"`
}

type ComputeInstanceGroupState struct {
	// The allocation policy of the instance group by zone and region. The structure is documented below.
	AllocationPolicy ComputeInstanceGroupAllocationPolicyPtrInput
	// The instance group creation timestamp.
	CreatedAt pulumi.StringPtrInput
	// Flag that protects the instance group from accidental deletion.
	DeletionProtection pulumi.BoolPtrInput
	// The deployment policy of the instance group. The structure is documented below.
	DeployPolicy ComputeInstanceGroupDeployPolicyPtrInput
	// A description of the boot disk.
	Description pulumi.StringPtrInput
	// The ID of the folder that the resources belong to.
	FolderId pulumi.StringPtrInput
	// Health check specifications. The structure is documented below.
	HealthChecks ComputeInstanceGroupHealthCheckArrayInput
	// The template for creating new instances. The structure is documented below.
	InstanceTemplate ComputeInstanceGroupInstanceTemplatePtrInput
	Instances        ComputeInstanceGroupInstanceArrayInput
	// A map of labels of metric.
	Labels pulumi.StringMapInput
	// Load balancing specifications. The structure is documented below.
	LoadBalancer ComputeInstanceGroupLoadBalancerPtrInput
	// Name template of the instance.\
	// In order to be unique it must contain at least one of instance unique placeholders:
	// {instance.short_id}
	// {instance.index}
	// combination of {instance.zone_id} and {instance.index_in_zone}
	// Example: my-instance-{instance.index}
	// If not set, default is used: {instance_group.id}-{instance.short_id}
	// It may also contain another placeholders, see metadata doc for full list.
	Name pulumi.StringPtrInput
	// The scaling policy of the instance group. The structure is documented below.
	ScalePolicy ComputeInstanceGroupScalePolicyPtrInput
	// The ID of the service account authorized for this instance.
	ServiceAccountId pulumi.StringPtrInput
	// The status of the instance.
	Status pulumi.StringPtrInput
	// A set of key/value  variables pairs to assign to the instance group.
	Variables pulumi.StringMapInput
}

func (ComputeInstanceGroupState) ElementType() reflect.Type {
	return reflect.TypeOf((*computeInstanceGroupState)(nil)).Elem()
}

type computeInstanceGroupArgs struct {
	// The allocation policy of the instance group by zone and region. The structure is documented below.
	AllocationPolicy ComputeInstanceGroupAllocationPolicy `pulumi:"allocationPolicy"`
	// Flag that protects the instance group from accidental deletion.
	DeletionProtection *bool `pulumi:"deletionProtection"`
	// The deployment policy of the instance group. The structure is documented below.
	DeployPolicy ComputeInstanceGroupDeployPolicy `pulumi:"deployPolicy"`
	// A description of the boot disk.
	Description *string `pulumi:"description"`
	// The ID of the folder that the resources belong to.
	FolderId *string `pulumi:"folderId"`
	// Health check specifications. The structure is documented below.
	HealthChecks []ComputeInstanceGroupHealthCheck `pulumi:"healthChecks"`
	// The template for creating new instances. The structure is documented below.
	InstanceTemplate ComputeInstanceGroupInstanceTemplate `pulumi:"instanceTemplate"`
	// A map of labels of metric.
	Labels map[string]string `pulumi:"labels"`
	// Load balancing specifications. The structure is documented below.
	LoadBalancer *ComputeInstanceGroupLoadBalancer `pulumi:"loadBalancer"`
	// Name template of the instance.\
	// In order to be unique it must contain at least one of instance unique placeholders:
	// {instance.short_id}
	// {instance.index}
	// combination of {instance.zone_id} and {instance.index_in_zone}
	// Example: my-instance-{instance.index}
	// If not set, default is used: {instance_group.id}-{instance.short_id}
	// It may also contain another placeholders, see metadata doc for full list.
	Name *string `pulumi:"name"`
	// The scaling policy of the instance group. The structure is documented below.
	ScalePolicy ComputeInstanceGroupScalePolicy `pulumi:"scalePolicy"`
	// The ID of the service account authorized for this instance.
	ServiceAccountId string `pulumi:"serviceAccountId"`
	// A set of key/value  variables pairs to assign to the instance group.
	Variables map[string]string `pulumi:"variables"`
}

// The set of arguments for constructing a ComputeInstanceGroup resource.
type ComputeInstanceGroupArgs struct {
	// The allocation policy of the instance group by zone and region. The structure is documented below.
	AllocationPolicy ComputeInstanceGroupAllocationPolicyInput
	// Flag that protects the instance group from accidental deletion.
	DeletionProtection pulumi.BoolPtrInput
	// The deployment policy of the instance group. The structure is documented below.
	DeployPolicy ComputeInstanceGroupDeployPolicyInput
	// A description of the boot disk.
	Description pulumi.StringPtrInput
	// The ID of the folder that the resources belong to.
	FolderId pulumi.StringPtrInput
	// Health check specifications. The structure is documented below.
	HealthChecks ComputeInstanceGroupHealthCheckArrayInput
	// The template for creating new instances. The structure is documented below.
	InstanceTemplate ComputeInstanceGroupInstanceTemplateInput
	// A map of labels of metric.
	Labels pulumi.StringMapInput
	// Load balancing specifications. The structure is documented below.
	LoadBalancer ComputeInstanceGroupLoadBalancerPtrInput
	// Name template of the instance.\
	// In order to be unique it must contain at least one of instance unique placeholders:
	// {instance.short_id}
	// {instance.index}
	// combination of {instance.zone_id} and {instance.index_in_zone}
	// Example: my-instance-{instance.index}
	// If not set, default is used: {instance_group.id}-{instance.short_id}
	// It may also contain another placeholders, see metadata doc for full list.
	Name pulumi.StringPtrInput
	// The scaling policy of the instance group. The structure is documented below.
	ScalePolicy ComputeInstanceGroupScalePolicyInput
	// The ID of the service account authorized for this instance.
	ServiceAccountId pulumi.StringInput
	// A set of key/value  variables pairs to assign to the instance group.
	Variables pulumi.StringMapInput
}

func (ComputeInstanceGroupArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*computeInstanceGroupArgs)(nil)).Elem()
}

type ComputeInstanceGroupInput interface {
	pulumi.Input

	ToComputeInstanceGroupOutput() ComputeInstanceGroupOutput
	ToComputeInstanceGroupOutputWithContext(ctx context.Context) ComputeInstanceGroupOutput
}

func (*ComputeInstanceGroup) ElementType() reflect.Type {
	return reflect.TypeOf((*ComputeInstanceGroup)(nil))
}

func (i *ComputeInstanceGroup) ToComputeInstanceGroupOutput() ComputeInstanceGroupOutput {
	return i.ToComputeInstanceGroupOutputWithContext(context.Background())
}

func (i *ComputeInstanceGroup) ToComputeInstanceGroupOutputWithContext(ctx context.Context) ComputeInstanceGroupOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ComputeInstanceGroupOutput)
}

func (i *ComputeInstanceGroup) ToComputeInstanceGroupPtrOutput() ComputeInstanceGroupPtrOutput {
	return i.ToComputeInstanceGroupPtrOutputWithContext(context.Background())
}

func (i *ComputeInstanceGroup) ToComputeInstanceGroupPtrOutputWithContext(ctx context.Context) ComputeInstanceGroupPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ComputeInstanceGroupPtrOutput)
}

type ComputeInstanceGroupPtrInput interface {
	pulumi.Input

	ToComputeInstanceGroupPtrOutput() ComputeInstanceGroupPtrOutput
	ToComputeInstanceGroupPtrOutputWithContext(ctx context.Context) ComputeInstanceGroupPtrOutput
}

type computeInstanceGroupPtrType ComputeInstanceGroupArgs

func (*computeInstanceGroupPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ComputeInstanceGroup)(nil))
}

func (i *computeInstanceGroupPtrType) ToComputeInstanceGroupPtrOutput() ComputeInstanceGroupPtrOutput {
	return i.ToComputeInstanceGroupPtrOutputWithContext(context.Background())
}

func (i *computeInstanceGroupPtrType) ToComputeInstanceGroupPtrOutputWithContext(ctx context.Context) ComputeInstanceGroupPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ComputeInstanceGroupPtrOutput)
}

// ComputeInstanceGroupArrayInput is an input type that accepts ComputeInstanceGroupArray and ComputeInstanceGroupArrayOutput values.
// You can construct a concrete instance of `ComputeInstanceGroupArrayInput` via:
//
//          ComputeInstanceGroupArray{ ComputeInstanceGroupArgs{...} }
type ComputeInstanceGroupArrayInput interface {
	pulumi.Input

	ToComputeInstanceGroupArrayOutput() ComputeInstanceGroupArrayOutput
	ToComputeInstanceGroupArrayOutputWithContext(context.Context) ComputeInstanceGroupArrayOutput
}

type ComputeInstanceGroupArray []ComputeInstanceGroupInput

func (ComputeInstanceGroupArray) ElementType() reflect.Type {
	return reflect.TypeOf(([]*ComputeInstanceGroup)(nil))
}

func (i ComputeInstanceGroupArray) ToComputeInstanceGroupArrayOutput() ComputeInstanceGroupArrayOutput {
	return i.ToComputeInstanceGroupArrayOutputWithContext(context.Background())
}

func (i ComputeInstanceGroupArray) ToComputeInstanceGroupArrayOutputWithContext(ctx context.Context) ComputeInstanceGroupArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ComputeInstanceGroupArrayOutput)
}

// ComputeInstanceGroupMapInput is an input type that accepts ComputeInstanceGroupMap and ComputeInstanceGroupMapOutput values.
// You can construct a concrete instance of `ComputeInstanceGroupMapInput` via:
//
//          ComputeInstanceGroupMap{ "key": ComputeInstanceGroupArgs{...} }
type ComputeInstanceGroupMapInput interface {
	pulumi.Input

	ToComputeInstanceGroupMapOutput() ComputeInstanceGroupMapOutput
	ToComputeInstanceGroupMapOutputWithContext(context.Context) ComputeInstanceGroupMapOutput
}

type ComputeInstanceGroupMap map[string]ComputeInstanceGroupInput

func (ComputeInstanceGroupMap) ElementType() reflect.Type {
	return reflect.TypeOf((map[string]*ComputeInstanceGroup)(nil))
}

func (i ComputeInstanceGroupMap) ToComputeInstanceGroupMapOutput() ComputeInstanceGroupMapOutput {
	return i.ToComputeInstanceGroupMapOutputWithContext(context.Background())
}

func (i ComputeInstanceGroupMap) ToComputeInstanceGroupMapOutputWithContext(ctx context.Context) ComputeInstanceGroupMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ComputeInstanceGroupMapOutput)
}

type ComputeInstanceGroupOutput struct {
	*pulumi.OutputState
}

func (ComputeInstanceGroupOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ComputeInstanceGroup)(nil))
}

func (o ComputeInstanceGroupOutput) ToComputeInstanceGroupOutput() ComputeInstanceGroupOutput {
	return o
}

func (o ComputeInstanceGroupOutput) ToComputeInstanceGroupOutputWithContext(ctx context.Context) ComputeInstanceGroupOutput {
	return o
}

func (o ComputeInstanceGroupOutput) ToComputeInstanceGroupPtrOutput() ComputeInstanceGroupPtrOutput {
	return o.ToComputeInstanceGroupPtrOutputWithContext(context.Background())
}

func (o ComputeInstanceGroupOutput) ToComputeInstanceGroupPtrOutputWithContext(ctx context.Context) ComputeInstanceGroupPtrOutput {
	return o.ApplyT(func(v ComputeInstanceGroup) *ComputeInstanceGroup {
		return &v
	}).(ComputeInstanceGroupPtrOutput)
}

type ComputeInstanceGroupPtrOutput struct {
	*pulumi.OutputState
}

func (ComputeInstanceGroupPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ComputeInstanceGroup)(nil))
}

func (o ComputeInstanceGroupPtrOutput) ToComputeInstanceGroupPtrOutput() ComputeInstanceGroupPtrOutput {
	return o
}

func (o ComputeInstanceGroupPtrOutput) ToComputeInstanceGroupPtrOutputWithContext(ctx context.Context) ComputeInstanceGroupPtrOutput {
	return o
}

type ComputeInstanceGroupArrayOutput struct{ *pulumi.OutputState }

func (ComputeInstanceGroupArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ComputeInstanceGroup)(nil))
}

func (o ComputeInstanceGroupArrayOutput) ToComputeInstanceGroupArrayOutput() ComputeInstanceGroupArrayOutput {
	return o
}

func (o ComputeInstanceGroupArrayOutput) ToComputeInstanceGroupArrayOutputWithContext(ctx context.Context) ComputeInstanceGroupArrayOutput {
	return o
}

func (o ComputeInstanceGroupArrayOutput) Index(i pulumi.IntInput) ComputeInstanceGroupOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ComputeInstanceGroup {
		return vs[0].([]ComputeInstanceGroup)[vs[1].(int)]
	}).(ComputeInstanceGroupOutput)
}

type ComputeInstanceGroupMapOutput struct{ *pulumi.OutputState }

func (ComputeInstanceGroupMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]ComputeInstanceGroup)(nil))
}

func (o ComputeInstanceGroupMapOutput) ToComputeInstanceGroupMapOutput() ComputeInstanceGroupMapOutput {
	return o
}

func (o ComputeInstanceGroupMapOutput) ToComputeInstanceGroupMapOutputWithContext(ctx context.Context) ComputeInstanceGroupMapOutput {
	return o
}

func (o ComputeInstanceGroupMapOutput) MapIndex(k pulumi.StringInput) ComputeInstanceGroupOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) ComputeInstanceGroup {
		return vs[0].(map[string]ComputeInstanceGroup)[vs[1].(string)]
	}).(ComputeInstanceGroupOutput)
}

func init() {
	pulumi.RegisterOutputType(ComputeInstanceGroupOutput{})
	pulumi.RegisterOutputType(ComputeInstanceGroupPtrOutput{})
	pulumi.RegisterOutputType(ComputeInstanceGroupArrayOutput{})
	pulumi.RegisterOutputType(ComputeInstanceGroupMapOutput{})
}
