// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "./types/input";
import * as outputs from "./types/output";
import * as utilities from "./utilities";

/**
 * ## Example Usage
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as yandex from "@airoh-io/pulumi-yandex";
 *
 * //
 * // Create a new Managed Kubernetes zonal Cluster.
 * //
 * const zonalCluster = new yandex.KubernetesCluster("zonalCluster", {
 *     description: "description",
 *     networkId: yandex_vpc_network.network_resource_name.id,
 *     master: {
 *         version: "1.30",
 *         zonal: {
 *             zone: yandex_vpc_subnet.subnet_resource_name.zone,
 *             subnetId: yandex_vpc_subnet.subnet_resource_name.id,
 *         },
 *         publicIp: true,
 *         securityGroupIds: [yandex_vpc_security_group.security_group_name.id],
 *         maintenancePolicy: {
 *             autoUpgrade: true,
 *             maintenanceWindows: [{
 *                 startTime: "15:00",
 *                 duration: "3h",
 *             }],
 *         },
 *         masterLogging: {
 *             enabled: true,
 *             logGroupId: yandex_logging_group.log_group_resoruce_name.id,
 *             kubeApiserverEnabled: true,
 *             clusterAutoscalerEnabled: true,
 *             eventsEnabled: true,
 *             auditEnabled: true,
 *         },
 *         scalePolicy: {
 *             autoScale: {
 *                 minResourcePresetId: "s-c4-m16",
 *             },
 *         },
 *     },
 *     serviceAccountId: yandex_iam_service_account.service_account_resource_name.id,
 *     nodeServiceAccountId: yandex_iam_service_account.node_service_account_resource_name.id,
 *     labels: {
 *         my_key: "my_value",
 *         my_other_key: "my_other_value",
 *     },
 *     releaseChannel: "RAPID",
 *     networkPolicyProvider: "CALICO",
 *     kmsProvider: {
 *         keyId: yandex_kms_symmetric_key.kms_key_resource_name.id,
 *     },
 * });
 * ```
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as yandex from "@airoh-io/pulumi-yandex";
 *
 * //
 * // Create a new Managed Kubernetes regional Cluster.
 * //
 * const regionalCluster = new yandex.KubernetesCluster("regionalCluster", {
 *     description: "description",
 *     networkId: yandex_vpc_network.network_resource_name.id,
 *     master: {
 *         regional: {
 *             region: "ru-central1",
 *             locations: [
 *                 {
 *                     zone: yandex_vpc_subnet.subnet_a_resource_name.zone,
 *                     subnetId: yandex_vpc_subnet.subnet_a_resource_name.id,
 *                 },
 *                 {
 *                     zone: yandex_vpc_subnet.subnet_b_resource_name.zone,
 *                     subnetId: yandex_vpc_subnet.subnet_b_resource_name.id,
 *                 },
 *                 {
 *                     zone: yandex_vpc_subnet.subnet_d_resource_name.zone,
 *                     subnetId: yandex_vpc_subnet.subnet_d_resource_name.id,
 *                 },
 *             ],
 *         },
 *         version: "1.30",
 *         publicIp: true,
 *         maintenancePolicy: {
 *             autoUpgrade: true,
 *             maintenanceWindows: [
 *                 {
 *                     day: "monday",
 *                     startTime: "15:00",
 *                     duration: "3h",
 *                 },
 *                 {
 *                     day: "friday",
 *                     startTime: "10:00",
 *                     duration: "4h30m",
 *                 },
 *             ],
 *         },
 *         masterLogging: {
 *             enabled: true,
 *             folderId: data.yandex_resourcemanager_folder.folder_resource_name.id,
 *             kubeApiserverEnabled: true,
 *             clusterAutoscalerEnabled: true,
 *             eventsEnabled: true,
 *             auditEnabled: true,
 *         },
 *         scalePolicy: {
 *             autoScale: {
 *                 minResourcePresetId: "s-c4-m16",
 *             },
 *         },
 *     },
 *     serviceAccountId: yandex_iam_service_account.service_account_resource_name.id,
 *     nodeServiceAccountId: yandex_iam_service_account.node_service_account_resource_name.id,
 *     labels: {
 *         my_key: "my_value",
 *         my_other_key: "my_other_value",
 *     },
 *     releaseChannel: "STABLE",
 * });
 * ```
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * ```
 *
 * ## Import
 *
 * The resource can be imported by using their `resource ID`. For getting the resource ID you can use Yandex Cloud [Web Console](https://console.yandex.cloud) or [YC CLI](https://yandex.cloud/docs/cli/quickstart).
 *
 * ```sh
 * $ pulumi import yandex:index/kubernetesCluster:KubernetesCluster <resource Name> <resource Id>
 * ```
 *
 * ```sh
 * $ pulumi import yandex:index/kubernetesCluster:KubernetesCluster regional_cluster ...
 * ```
 */
export class KubernetesCluster extends pulumi.CustomResource {
    /**
     * Get an existing KubernetesCluster resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: KubernetesClusterState, opts?: pulumi.CustomResourceOptions): KubernetesCluster {
        return new KubernetesCluster(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'yandex:index/kubernetesCluster:KubernetesCluster';

    /**
     * Returns true if the given object is an instance of KubernetesCluster.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is KubernetesCluster {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === KubernetesCluster.__pulumiType;
    }

    /**
     * CIDR block. IP range for allocating pod addresses. It should not overlap with any subnet in the network the Kubernetes cluster located in. Static routes will be set up for this CIDR blocks in node subnets.
     */
    declare public readonly clusterIpv4Range: pulumi.Output<string>;
    /**
     * Identical to `clusterIpv4Range` but for IPv6 protocol.
     */
    declare public readonly clusterIpv6Range: pulumi.Output<string>;
    /**
     * The creation timestamp of the resource.
     */
    declare public /*out*/ readonly createdAt: pulumi.Output<string>;
    /**
     * The resource description.
     */
    declare public readonly description: pulumi.Output<string>;
    /**
     * The folder identifier that resource belongs to. If it is not provided, the default provider `folder-id` is used.
     */
    declare public readonly folderId: pulumi.Output<string>;
    /**
     * Health of the Kubernetes cluster.
     */
    declare public /*out*/ readonly health: pulumi.Output<string>;
    /**
     * Cluster KMS provider parameters.
     */
    declare public readonly kmsProvider: pulumi.Output<outputs.KubernetesClusterKmsProvider | undefined>;
    /**
     * A set of key/value label pairs which assigned to resource.
     */
    declare public readonly labels: pulumi.Output<{[key: string]: string}>;
    /**
     * Log group where cluster stores cluster system logs, like audit, events, or control plane logs.
     */
    declare public /*out*/ readonly logGroupId: pulumi.Output<string>;
    /**
     * Kubernetes master configuration options.
     */
    declare public readonly master: pulumi.Output<outputs.KubernetesClusterMaster>;
    /**
     * The resource name.
     */
    declare public readonly name: pulumi.Output<string>;
    /**
     * The ID of the cluster network.
     */
    declare public readonly networkId: pulumi.Output<string>;
    /**
     * Network Implementation options.
     */
    declare public readonly networkImplementation: pulumi.Output<outputs.KubernetesClusterNetworkImplementation | undefined>;
    /**
     * Network policy provider for the cluster. Possible values: `CALICO`.
     */
    declare public readonly networkPolicyProvider: pulumi.Output<string | undefined>;
    /**
     * Size of the masks that are assigned to each node in the cluster. Effectively limits maximum number of pods for each node.
     */
    declare public readonly nodeIpv4CidrMaskSize: pulumi.Output<number | undefined>;
    /**
     * Service account to be used by the worker nodes of the Kubernetes cluster to access Container Registry or to push node logs and metrics.
     */
    declare public readonly nodeServiceAccountId: pulumi.Output<string>;
    /**
     * Cluster release channel.
     */
    declare public readonly releaseChannel: pulumi.Output<string>;
    /**
     * Service account to be used for provisioning Compute Cloud and VPC resources for Kubernetes cluster. Selected service account should have `edit` role on the folder where the Kubernetes cluster will be located and on the folder where selected network resides.
     */
    declare public readonly serviceAccountId: pulumi.Output<string>;
    /**
     * CIDR block. IP range Kubernetes service Kubernetes cluster IP addresses will be allocated from. It should not overlap with any subnet in the network the Kubernetes cluster located in.
     */
    declare public readonly serviceIpv4Range: pulumi.Output<string>;
    /**
     * Identical to service*ipv4*range but for IPv6 protocol.
     */
    declare public readonly serviceIpv6Range: pulumi.Output<string>;
    /**
     * Status of the Kubernetes cluster.
     */
    declare public /*out*/ readonly status: pulumi.Output<string>;

    /**
     * Create a KubernetesCluster resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args: KubernetesClusterArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: KubernetesClusterArgs | KubernetesClusterState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as KubernetesClusterState | undefined;
            resourceInputs["clusterIpv4Range"] = state?.clusterIpv4Range;
            resourceInputs["clusterIpv6Range"] = state?.clusterIpv6Range;
            resourceInputs["createdAt"] = state?.createdAt;
            resourceInputs["description"] = state?.description;
            resourceInputs["folderId"] = state?.folderId;
            resourceInputs["health"] = state?.health;
            resourceInputs["kmsProvider"] = state?.kmsProvider;
            resourceInputs["labels"] = state?.labels;
            resourceInputs["logGroupId"] = state?.logGroupId;
            resourceInputs["master"] = state?.master;
            resourceInputs["name"] = state?.name;
            resourceInputs["networkId"] = state?.networkId;
            resourceInputs["networkImplementation"] = state?.networkImplementation;
            resourceInputs["networkPolicyProvider"] = state?.networkPolicyProvider;
            resourceInputs["nodeIpv4CidrMaskSize"] = state?.nodeIpv4CidrMaskSize;
            resourceInputs["nodeServiceAccountId"] = state?.nodeServiceAccountId;
            resourceInputs["releaseChannel"] = state?.releaseChannel;
            resourceInputs["serviceAccountId"] = state?.serviceAccountId;
            resourceInputs["serviceIpv4Range"] = state?.serviceIpv4Range;
            resourceInputs["serviceIpv6Range"] = state?.serviceIpv6Range;
            resourceInputs["status"] = state?.status;
        } else {
            const args = argsOrState as KubernetesClusterArgs | undefined;
            if (args?.master === undefined && !opts.urn) {
                throw new Error("Missing required property 'master'");
            }
            if (args?.networkId === undefined && !opts.urn) {
                throw new Error("Missing required property 'networkId'");
            }
            if (args?.nodeServiceAccountId === undefined && !opts.urn) {
                throw new Error("Missing required property 'nodeServiceAccountId'");
            }
            if (args?.serviceAccountId === undefined && !opts.urn) {
                throw new Error("Missing required property 'serviceAccountId'");
            }
            resourceInputs["clusterIpv4Range"] = args?.clusterIpv4Range;
            resourceInputs["clusterIpv6Range"] = args?.clusterIpv6Range;
            resourceInputs["description"] = args?.description;
            resourceInputs["folderId"] = args?.folderId;
            resourceInputs["kmsProvider"] = args?.kmsProvider;
            resourceInputs["labels"] = args?.labels;
            resourceInputs["master"] = args?.master;
            resourceInputs["name"] = args?.name;
            resourceInputs["networkId"] = args?.networkId;
            resourceInputs["networkImplementation"] = args?.networkImplementation;
            resourceInputs["networkPolicyProvider"] = args?.networkPolicyProvider;
            resourceInputs["nodeIpv4CidrMaskSize"] = args?.nodeIpv4CidrMaskSize;
            resourceInputs["nodeServiceAccountId"] = args?.nodeServiceAccountId;
            resourceInputs["releaseChannel"] = args?.releaseChannel;
            resourceInputs["serviceAccountId"] = args?.serviceAccountId;
            resourceInputs["serviceIpv4Range"] = args?.serviceIpv4Range;
            resourceInputs["serviceIpv6Range"] = args?.serviceIpv6Range;
            resourceInputs["createdAt"] = undefined /*out*/;
            resourceInputs["health"] = undefined /*out*/;
            resourceInputs["logGroupId"] = undefined /*out*/;
            resourceInputs["status"] = undefined /*out*/;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        super(KubernetesCluster.__pulumiType, name, resourceInputs, opts);
    }
}

/**
 * Input properties used for looking up and filtering KubernetesCluster resources.
 */
export interface KubernetesClusterState {
    /**
     * CIDR block. IP range for allocating pod addresses. It should not overlap with any subnet in the network the Kubernetes cluster located in. Static routes will be set up for this CIDR blocks in node subnets.
     */
    clusterIpv4Range?: pulumi.Input<string>;
    /**
     * Identical to `clusterIpv4Range` but for IPv6 protocol.
     */
    clusterIpv6Range?: pulumi.Input<string>;
    /**
     * The creation timestamp of the resource.
     */
    createdAt?: pulumi.Input<string>;
    /**
     * The resource description.
     */
    description?: pulumi.Input<string>;
    /**
     * The folder identifier that resource belongs to. If it is not provided, the default provider `folder-id` is used.
     */
    folderId?: pulumi.Input<string>;
    /**
     * Health of the Kubernetes cluster.
     */
    health?: pulumi.Input<string>;
    /**
     * Cluster KMS provider parameters.
     */
    kmsProvider?: pulumi.Input<inputs.KubernetesClusterKmsProvider>;
    /**
     * A set of key/value label pairs which assigned to resource.
     */
    labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * Log group where cluster stores cluster system logs, like audit, events, or control plane logs.
     */
    logGroupId?: pulumi.Input<string>;
    /**
     * Kubernetes master configuration options.
     */
    master?: pulumi.Input<inputs.KubernetesClusterMaster>;
    /**
     * The resource name.
     */
    name?: pulumi.Input<string>;
    /**
     * The ID of the cluster network.
     */
    networkId?: pulumi.Input<string>;
    /**
     * Network Implementation options.
     */
    networkImplementation?: pulumi.Input<inputs.KubernetesClusterNetworkImplementation>;
    /**
     * Network policy provider for the cluster. Possible values: `CALICO`.
     */
    networkPolicyProvider?: pulumi.Input<string>;
    /**
     * Size of the masks that are assigned to each node in the cluster. Effectively limits maximum number of pods for each node.
     */
    nodeIpv4CidrMaskSize?: pulumi.Input<number>;
    /**
     * Service account to be used by the worker nodes of the Kubernetes cluster to access Container Registry or to push node logs and metrics.
     */
    nodeServiceAccountId?: pulumi.Input<string>;
    /**
     * Cluster release channel.
     */
    releaseChannel?: pulumi.Input<string>;
    /**
     * Service account to be used for provisioning Compute Cloud and VPC resources for Kubernetes cluster. Selected service account should have `edit` role on the folder where the Kubernetes cluster will be located and on the folder where selected network resides.
     */
    serviceAccountId?: pulumi.Input<string>;
    /**
     * CIDR block. IP range Kubernetes service Kubernetes cluster IP addresses will be allocated from. It should not overlap with any subnet in the network the Kubernetes cluster located in.
     */
    serviceIpv4Range?: pulumi.Input<string>;
    /**
     * Identical to service*ipv4*range but for IPv6 protocol.
     */
    serviceIpv6Range?: pulumi.Input<string>;
    /**
     * Status of the Kubernetes cluster.
     */
    status?: pulumi.Input<string>;
}

/**
 * The set of arguments for constructing a KubernetesCluster resource.
 */
export interface KubernetesClusterArgs {
    /**
     * CIDR block. IP range for allocating pod addresses. It should not overlap with any subnet in the network the Kubernetes cluster located in. Static routes will be set up for this CIDR blocks in node subnets.
     */
    clusterIpv4Range?: pulumi.Input<string>;
    /**
     * Identical to `clusterIpv4Range` but for IPv6 protocol.
     */
    clusterIpv6Range?: pulumi.Input<string>;
    /**
     * The resource description.
     */
    description?: pulumi.Input<string>;
    /**
     * The folder identifier that resource belongs to. If it is not provided, the default provider `folder-id` is used.
     */
    folderId?: pulumi.Input<string>;
    /**
     * Cluster KMS provider parameters.
     */
    kmsProvider?: pulumi.Input<inputs.KubernetesClusterKmsProvider>;
    /**
     * A set of key/value label pairs which assigned to resource.
     */
    labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * Kubernetes master configuration options.
     */
    master: pulumi.Input<inputs.KubernetesClusterMaster>;
    /**
     * The resource name.
     */
    name?: pulumi.Input<string>;
    /**
     * The ID of the cluster network.
     */
    networkId: pulumi.Input<string>;
    /**
     * Network Implementation options.
     */
    networkImplementation?: pulumi.Input<inputs.KubernetesClusterNetworkImplementation>;
    /**
     * Network policy provider for the cluster. Possible values: `CALICO`.
     */
    networkPolicyProvider?: pulumi.Input<string>;
    /**
     * Size of the masks that are assigned to each node in the cluster. Effectively limits maximum number of pods for each node.
     */
    nodeIpv4CidrMaskSize?: pulumi.Input<number>;
    /**
     * Service account to be used by the worker nodes of the Kubernetes cluster to access Container Registry or to push node logs and metrics.
     */
    nodeServiceAccountId: pulumi.Input<string>;
    /**
     * Cluster release channel.
     */
    releaseChannel?: pulumi.Input<string>;
    /**
     * Service account to be used for provisioning Compute Cloud and VPC resources for Kubernetes cluster. Selected service account should have `edit` role on the folder where the Kubernetes cluster will be located and on the folder where selected network resides.
     */
    serviceAccountId: pulumi.Input<string>;
    /**
     * CIDR block. IP range Kubernetes service Kubernetes cluster IP addresses will be allocated from. It should not overlap with any subnet in the network the Kubernetes cluster located in.
     */
    serviceIpv4Range?: pulumi.Input<string>;
    /**
     * Identical to service*ipv4*range but for IPv6 protocol.
     */
    serviceIpv6Range?: pulumi.Input<string>;
}
