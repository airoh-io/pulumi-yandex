// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "./types/input";
import * as outputs from "./types/output";
import * as utilities from "./utilities";

/**
 * Creates a Yandex Managed Kubernetes Cluster Node Group. For more information, see [the official documentation](https://yandex.cloud/docs/managed-kubernetes/concepts/#node-group).
 *
 * ## Example Usage
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as yandex from "@airoh-io/pulumi-yandex";
 *
 * //
 * // Create a new Managed Kubernetes Node Group.
 * //
 * const myNodeGroup = new yandex.KubernetesNodeGroup("myNodeGroup", {
 *     clusterId: yandex_kubernetes_cluster.my_cluster.id,
 *     description: "description",
 *     version: "1.30",
 *     labels: {
 *         key: "value",
 *     },
 *     instanceTemplate: {
 *         platformId: "standard-v2",
 *         networkInterfaces: [{
 *             nat: true,
 *             subnetIds: [yandex_vpc_subnet.my_subnet.id],
 *         }],
 *         resources: {
 *             memory: 2,
 *             cores: 2,
 *         },
 *         bootDisk: {
 *             type: "network-hdd",
 *             size: 64,
 *         },
 *         schedulingPolicy: {
 *             preemptible: false,
 *         },
 *         containerRuntime: {
 *             type: "containerd",
 *         },
 *     },
 *     scalePolicy: {
 *         fixedScale: {
 *             size: 1,
 *         },
 *     },
 *     allocationPolicy: {
 *         locations: [{
 *             zone: "ru-central1-a",
 *         }],
 *     },
 *     maintenancePolicy: {
 *         autoUpgrade: true,
 *         autoRepair: true,
 *         maintenanceWindows: [
 *             {
 *                 day: "monday",
 *                 startTime: "15:00",
 *                 duration: "3h",
 *             },
 *             {
 *                 day: "friday",
 *                 startTime: "10:00",
 *                 duration: "4h30m",
 *             },
 *         ],
 *     },
 * });
 * ```
 *
 * ## Import
 *
 * The resource can be imported by using their `resource ID`. For getting the resource ID you can use Yandex Cloud [Web Console](https://console.yandex.cloud) or [YC CLI](https://yandex.cloud/docs/cli/quickstart).
 *
 * ```sh
 * $ pulumi import yandex:index/kubernetesNodeGroup:KubernetesNodeGroup <resource Name> <resource Id>
 * ```
 *
 * ```sh
 * $ pulumi import yandex:index/kubernetesNodeGroup:KubernetesNodeGroup my_node_group ...
 * ```
 */
export class KubernetesNodeGroup extends pulumi.CustomResource {
    /**
     * Get an existing KubernetesNodeGroup resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: KubernetesNodeGroupState, opts?: pulumi.CustomResourceOptions): KubernetesNodeGroup {
        return new KubernetesNodeGroup(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'yandex:index/kubernetesNodeGroup:KubernetesNodeGroup';

    /**
     * Returns true if the given object is an instance of KubernetesNodeGroup.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is KubernetesNodeGroup {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === KubernetesNodeGroup.__pulumiType;
    }

    /**
     * This argument specify subnets (zones), that will be used by node group compute instances.
     */
    declare public readonly allocationPolicy: pulumi.Output<outputs.KubernetesNodeGroupAllocationPolicy>;
    /**
     * A list of allowed unsafe `sysctl` parameters for this node group. For more details see [documentation](https://kubernetes.io/docs/tasks/administer-cluster/sysctl-cluster).
     */
    declare public readonly allowedUnsafeSysctls: pulumi.Output<string[] | undefined>;
    /**
     * The ID of the Kubernetes cluster that this node group belongs to.
     */
    declare public readonly clusterId: pulumi.Output<string>;
    /**
     * The creation timestamp of the resource.
     */
    declare public /*out*/ readonly createdAt: pulumi.Output<string>;
    /**
     * Deploy policy of the node group.
     */
    declare public readonly deployPolicy: pulumi.Output<outputs.KubernetesNodeGroupDeployPolicy>;
    /**
     * The resource description.
     */
    declare public readonly description: pulumi.Output<string>;
    /**
     * ID of instance group that is used to manage this Kubernetes node group.
     */
    declare public /*out*/ readonly instanceGroupId: pulumi.Output<string>;
    /**
     * Template used to create compute instances in this Kubernetes node group.
     */
    declare public readonly instanceTemplate: pulumi.Output<outputs.KubernetesNodeGroupInstanceTemplate>;
    /**
     * A set of key/value label pairs which assigned to resource.
     */
    declare public readonly labels: pulumi.Output<{[key: string]: string}>;
    /**
     * Maintenance policy for this Kubernetes node group. If policy is omitted, automatic revision upgrades are enabled and could happen at any time. Revision upgrades are performed only within the same minor version, e.g. `1.29`. Minor version upgrades (e.g. `1.29`->`1.30`) should be performed manually.
     */
    declare public readonly maintenancePolicy: pulumi.Output<outputs.KubernetesNodeGroupMaintenancePolicy>;
    /**
     * The resource name.
     */
    declare public readonly name: pulumi.Output<string>;
    /**
     * A set of key/value label pairs, that are assigned to all the nodes of this Kubernetes node group.
     */
    declare public readonly nodeLabels: pulumi.Output<{[key: string]: string} | undefined>;
    /**
     * A list of Kubernetes taints, that are applied to all the nodes of this Kubernetes node group.
     */
    declare public readonly nodeTaints: pulumi.Output<string[] | undefined>;
    /**
     * Scale policy of the node group.
     */
    declare public readonly scalePolicy: pulumi.Output<outputs.KubernetesNodeGroupScalePolicy>;
    /**
     * Status of the Kubernetes node group.
     */
    declare public /*out*/ readonly status: pulumi.Output<string>;
    /**
     * Version of Kubernetes that will be used for Kubernetes node group.
     */
    declare public readonly version: pulumi.Output<string>;
    /**
     * Information about Kubernetes node group version.
     */
    declare public /*out*/ readonly versionInfos: pulumi.Output<outputs.KubernetesNodeGroupVersionInfo[]>;

    /**
     * Create a KubernetesNodeGroup resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args: KubernetesNodeGroupArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: KubernetesNodeGroupArgs | KubernetesNodeGroupState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as KubernetesNodeGroupState | undefined;
            resourceInputs["allocationPolicy"] = state?.allocationPolicy;
            resourceInputs["allowedUnsafeSysctls"] = state?.allowedUnsafeSysctls;
            resourceInputs["clusterId"] = state?.clusterId;
            resourceInputs["createdAt"] = state?.createdAt;
            resourceInputs["deployPolicy"] = state?.deployPolicy;
            resourceInputs["description"] = state?.description;
            resourceInputs["instanceGroupId"] = state?.instanceGroupId;
            resourceInputs["instanceTemplate"] = state?.instanceTemplate;
            resourceInputs["labels"] = state?.labels;
            resourceInputs["maintenancePolicy"] = state?.maintenancePolicy;
            resourceInputs["name"] = state?.name;
            resourceInputs["nodeLabels"] = state?.nodeLabels;
            resourceInputs["nodeTaints"] = state?.nodeTaints;
            resourceInputs["scalePolicy"] = state?.scalePolicy;
            resourceInputs["status"] = state?.status;
            resourceInputs["version"] = state?.version;
            resourceInputs["versionInfos"] = state?.versionInfos;
        } else {
            const args = argsOrState as KubernetesNodeGroupArgs | undefined;
            if (args?.clusterId === undefined && !opts.urn) {
                throw new Error("Missing required property 'clusterId'");
            }
            if (args?.instanceTemplate === undefined && !opts.urn) {
                throw new Error("Missing required property 'instanceTemplate'");
            }
            if (args?.scalePolicy === undefined && !opts.urn) {
                throw new Error("Missing required property 'scalePolicy'");
            }
            resourceInputs["allocationPolicy"] = args?.allocationPolicy;
            resourceInputs["allowedUnsafeSysctls"] = args?.allowedUnsafeSysctls;
            resourceInputs["clusterId"] = args?.clusterId;
            resourceInputs["deployPolicy"] = args?.deployPolicy;
            resourceInputs["description"] = args?.description;
            resourceInputs["instanceTemplate"] = args?.instanceTemplate;
            resourceInputs["labels"] = args?.labels;
            resourceInputs["maintenancePolicy"] = args?.maintenancePolicy;
            resourceInputs["name"] = args?.name;
            resourceInputs["nodeLabels"] = args?.nodeLabels;
            resourceInputs["nodeTaints"] = args?.nodeTaints;
            resourceInputs["scalePolicy"] = args?.scalePolicy;
            resourceInputs["version"] = args?.version;
            resourceInputs["createdAt"] = undefined /*out*/;
            resourceInputs["instanceGroupId"] = undefined /*out*/;
            resourceInputs["status"] = undefined /*out*/;
            resourceInputs["versionInfos"] = undefined /*out*/;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        super(KubernetesNodeGroup.__pulumiType, name, resourceInputs, opts);
    }
}

/**
 * Input properties used for looking up and filtering KubernetesNodeGroup resources.
 */
export interface KubernetesNodeGroupState {
    /**
     * This argument specify subnets (zones), that will be used by node group compute instances.
     */
    allocationPolicy?: pulumi.Input<inputs.KubernetesNodeGroupAllocationPolicy>;
    /**
     * A list of allowed unsafe `sysctl` parameters for this node group. For more details see [documentation](https://kubernetes.io/docs/tasks/administer-cluster/sysctl-cluster).
     */
    allowedUnsafeSysctls?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The ID of the Kubernetes cluster that this node group belongs to.
     */
    clusterId?: pulumi.Input<string>;
    /**
     * The creation timestamp of the resource.
     */
    createdAt?: pulumi.Input<string>;
    /**
     * Deploy policy of the node group.
     */
    deployPolicy?: pulumi.Input<inputs.KubernetesNodeGroupDeployPolicy>;
    /**
     * The resource description.
     */
    description?: pulumi.Input<string>;
    /**
     * ID of instance group that is used to manage this Kubernetes node group.
     */
    instanceGroupId?: pulumi.Input<string>;
    /**
     * Template used to create compute instances in this Kubernetes node group.
     */
    instanceTemplate?: pulumi.Input<inputs.KubernetesNodeGroupInstanceTemplate>;
    /**
     * A set of key/value label pairs which assigned to resource.
     */
    labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * Maintenance policy for this Kubernetes node group. If policy is omitted, automatic revision upgrades are enabled and could happen at any time. Revision upgrades are performed only within the same minor version, e.g. `1.29`. Minor version upgrades (e.g. `1.29`->`1.30`) should be performed manually.
     */
    maintenancePolicy?: pulumi.Input<inputs.KubernetesNodeGroupMaintenancePolicy>;
    /**
     * The resource name.
     */
    name?: pulumi.Input<string>;
    /**
     * A set of key/value label pairs, that are assigned to all the nodes of this Kubernetes node group.
     */
    nodeLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * A list of Kubernetes taints, that are applied to all the nodes of this Kubernetes node group.
     */
    nodeTaints?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Scale policy of the node group.
     */
    scalePolicy?: pulumi.Input<inputs.KubernetesNodeGroupScalePolicy>;
    /**
     * Status of the Kubernetes node group.
     */
    status?: pulumi.Input<string>;
    /**
     * Version of Kubernetes that will be used for Kubernetes node group.
     */
    version?: pulumi.Input<string>;
    /**
     * Information about Kubernetes node group version.
     */
    versionInfos?: pulumi.Input<pulumi.Input<inputs.KubernetesNodeGroupVersionInfo>[]>;
}

/**
 * The set of arguments for constructing a KubernetesNodeGroup resource.
 */
export interface KubernetesNodeGroupArgs {
    /**
     * This argument specify subnets (zones), that will be used by node group compute instances.
     */
    allocationPolicy?: pulumi.Input<inputs.KubernetesNodeGroupAllocationPolicy>;
    /**
     * A list of allowed unsafe `sysctl` parameters for this node group. For more details see [documentation](https://kubernetes.io/docs/tasks/administer-cluster/sysctl-cluster).
     */
    allowedUnsafeSysctls?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The ID of the Kubernetes cluster that this node group belongs to.
     */
    clusterId: pulumi.Input<string>;
    /**
     * Deploy policy of the node group.
     */
    deployPolicy?: pulumi.Input<inputs.KubernetesNodeGroupDeployPolicy>;
    /**
     * The resource description.
     */
    description?: pulumi.Input<string>;
    /**
     * Template used to create compute instances in this Kubernetes node group.
     */
    instanceTemplate: pulumi.Input<inputs.KubernetesNodeGroupInstanceTemplate>;
    /**
     * A set of key/value label pairs which assigned to resource.
     */
    labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * Maintenance policy for this Kubernetes node group. If policy is omitted, automatic revision upgrades are enabled and could happen at any time. Revision upgrades are performed only within the same minor version, e.g. `1.29`. Minor version upgrades (e.g. `1.29`->`1.30`) should be performed manually.
     */
    maintenancePolicy?: pulumi.Input<inputs.KubernetesNodeGroupMaintenancePolicy>;
    /**
     * The resource name.
     */
    name?: pulumi.Input<string>;
    /**
     * A set of key/value label pairs, that are assigned to all the nodes of this Kubernetes node group.
     */
    nodeLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * A list of Kubernetes taints, that are applied to all the nodes of this Kubernetes node group.
     */
    nodeTaints?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Scale policy of the node group.
     */
    scalePolicy: pulumi.Input<inputs.KubernetesNodeGroupScalePolicy>;
    /**
     * Version of Kubernetes that will be used for Kubernetes node group.
     */
    version?: pulumi.Input<string>;
}
